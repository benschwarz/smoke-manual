<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
	"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" type="text/css" href="../templates/layout.css"/>
	<link rel="stylesheet" type="text/css" href="../templates/syntax.css"/>
	<link rel="stylesheet" type="text/css" href="../templates/user.css"/>
	
	<meta name="author" content="Ben Schwarz" />
	<meta name="subject" content="Smoke, a ruby DSL for reinterpreting the web" />
	<meta name="keywords" content="ruby, dsl, web, programming, parsing" />
</head>
<body>
	<div class="frontcover"></div>
	<div class="halftitlepage">
		<h1 class="no-toc">Smoke</h1>
	</div>

	<div class="titlepage">
		<h1 class="no-toc">Smoke</h1>
		<p class="no-toc">Ben Schwarz</p>
	</div>
	
	<div class="imprint">
		<p>Copyright Ben Schwarz 2009. All rights reserved.</p>
	</div>
	
	<div class="chapters">
		<div class="chapter"><h1>Introduction</h1>

<p>Smoke is a DSL written in Ruby. Its primary goal is to be a very simple interface to query many online sources, chop them up into usable pieces and use them in ways that the source provider may have never imagined.</p>

<p>This document is aimed to serve as a guide for usage to get you started.</p>

<h2 id="the-concept">The concept</h2>

<p>The concept comes from using <a href="http://pipes.yahoo.com">Yahoo Pipes</a> to make web based mash ups: Get a list of tv shows for my torrent client, compile a recipe book or make tools to give me a list of albums that artists in my music library are about to be released.</p>


</div><div class="chapter"><h1>Diving straight in</h1>

<p>Say you wanted to get your twitter stream, doesn't sound too hard? It isn't!</p>

<p>The first thing that you'll need to do is discover your source. Smoke supports YQL, XML, JSON and RSS / Atom.</p>

<pre class="sunburst ruby"><span class="Keyword">require</span> <span class="String"><span class="String">'</span>smoke<span class="String">'</span></span>
<span class="Support">Smoke</span>.<span class="Entity">data</span>(<span class="Constant"><span class="Constant">:</span>twitter</span>) <span class="Keyword">do</span>
  url <span class="String"><span class="String">&quot;</span>http://twitter.com/users/show.json?screen_name=benschwarz<span class="String">&quot;</span></span>
<span class="Keyword">end</span>
</pre>

<p>Now that the source has been defined you can use it like this:</p>

<pre class="sunburst ruby"><span class="Support">Smoke</span>.<span class="Entity">twitter</span>.output
</pre>

<p>This will give you an array of hashes, each hash will be a tweet.</p>

<p>Right now you're probably sitting there smugly thinking to yourself "yeah, I could do that myself pretty easily."</p>

<p>Well, you smug bastard, there is some more we can do.
Perhaps you'd like to open an interface to pull twitter feeds for multiple users? Maybe you'd like to strip out tweets that were directed at someone?</p>

<pre class="sunburst ruby"><span class="Support">Smoke</span>.<span class="Entity">data</span>(<span class="Constant"><span class="Constant">:</span>twitter</span>) <span class="Keyword">do</span>
  prepare <span class="Keyword">do</span>
    url <span class="String"><span class="String">&quot;</span>http://twitter.com/users/show.json?screen_name=<span class="StringEmbeddedSource"><span class="StringEmbeddedSource">#{</span>username<span class="StringEmbeddedSource">}</span></span><span class="String">&quot;</span></span>
  <span class="Keyword">end</span>
  
  discard <span class="Constant"><span class="Constant">:</span>text</span>, <span class="StringRegexp"><span class="StringRegexp">/</span></span><span class="StringRegexp">@<span class="StringRegexpSpecial">\w</span></span><span class="StringRegexp"><span class="StringRegexp">/</span></span>
<span class="Keyword">end</span>
</pre>

<p>Now that you've suggested that a username is required for the query. You need to send through a username.</p>

<pre class="sunburst ruby"><span class="Support">Smoke</span>.<span class="Entity">twitter</span>.<span class="Entity">username</span>(<span class="Constant"><span class="Constant">:</span>benschwarz</span>).output
</pre>

<p>The smoke DSL is pretty easy to pickup. All methods are well documented using rdoc, so exploring the API should be easy.</p>


</div><div class="chapter"><h1>Cool stuff smoke does</h1>

<h2 id="output-formats">Output formats</h2>

<p>Not only does Smoke query a web service and automagically translate Json or XML to an array of ruby hashes, it will also output in Json or Yaml.</p>

<pre class="sunburst ruby"><span class="Support">Smoke</span>.<span class="Entity">twitter</span>.<span class="Entity">output</span>(<span class="Constant"><span class="Constant">:</span>yaml</span>)
</pre>

<h2 id="smart-requests">Smart requests</h2>

<p>All requests ask the web service on the other end to gzip its data before it delivers it back to smoke. This means that less data is transferred - You can compress plain text pretty successfully.</p>

<p>Not all services support / implement gzip, but for those who do, its a clear win.</p>


</div>
	</div>

	<div class="white_page"></div>
	<div class="white_page"></div>
	<div class="backcover"></div>
</body>
</html>